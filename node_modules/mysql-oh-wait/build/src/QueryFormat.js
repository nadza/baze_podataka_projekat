"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isStringable(val) {
    return typeof val !== 'undefined'
        && (typeof val === 'string'
            || typeof val === 'number'
            || typeof val === 'boolean'
            || val instanceof Date
            || val === null);
}
function isStringableArray(val) {
    return val instanceof Array && (val.length > 0 && elementsAreOfType(val, isStringable));
}
function isStringableArrayArray(val) {
    return val instanceof Array && (val.length > 0 && elementsAreOfType(val, isStringableArray));
}
function isStringableObj(val) {
    return isObjectAndAllValuesAreOfType(val, isStringable);
}
function isStringableArrayObj(val) {
    return isObjectAndAllValuesAreOfType(val, isStringableArray);
}
function isStringableArrayArrayObj(val) {
    return isObjectAndAllValuesAreOfType(val, isStringableArrayArray);
}
function isStringableMixedObj(val) {
    return isPropObject(val)
        && isObjectAndAllValuesAreOfType(val, function (x) { return isStringable(x) || isStringableArray(x) || isStringableArrayArray(x); });
}
function isPropObject(val) {
    return typeof val === "object" && !(val instanceof Array);
}
function isObjectAndAllValuesAreOfType(val, typecheck) {
    return isPropObject(val)
        && elementsAreOfType(Object.values(val), typecheck);
}
function elementsAreOfType(els, typeCheck) {
    return els.filter(typeCheck).length === els.length;
}
var QueryFormat = /** @class */ (function () {
    function QueryFormat(connection) {
        this.matchesCount = null;
        this.values = null;
        this.copyOfValuesWhenArray = null;
        this.escape = connection.escape.bind(connection);
        this.replacer = this.replacer.bind(this);
    }
    QueryFormat.prototype.mapEscape = function (val, depth, ref) {
        var _this = this;
        if (val instanceof Date) {
            val = QueryFormat.toMysqlDatetime(val);
        }
        if (typeof val === 'boolean') {
            val = val ? 1 : 0;
        }
        else if (val === null) {
            return 'NULL';
        }
        if (isStringable(val)) {
            return this.escape(val);
        }
        if (!(val instanceof Array)) {
            throw new Error("Unsupported custom placeholder value for ref : ".concat(ref, ", type of value: ").concat(typeof val));
        }
        if (val.length <= 0) {
            throw new Error('Cannot pass empty arrays as values');
        }
        if (depth > 2) {
            throw new Error('Supplied value has too many depth levels, max supported is 2 for INSERT VALUES :ref or 1 for IN (:ref)');
        }
        if (isStringableArray(val)) {
            return val.map(function (el) { return _this.mapEscape(el, depth + 1); });
        }
        else if (isStringableArrayArray(val)) {
            return val.map(function (el) { return _this.mapEscape(el, depth + 1); });
        }
        else {
            return val;
        }
    };
    QueryFormat.toMysqlDatetime = function (d) {
        return d.toISOString().slice(0, 19).replace('T', ' ');
    };
    QueryFormat.prototype.joinUseParenthesis = function (escapedValues) {
        if (typeof escapedValues === 'string') {
            return escapedValues;
        }
        if (escapedValues.length <= 0) {
            throw new Error('Empty arrays are not allowed as value');
        }
        var glueWithColonsSurroundWithParenthesis = function (el) { return "(".concat(el.join(', '), ")"); };
        if (isStringableArrayArray(escapedValues)) {
            escapedValues = escapedValues.map(glueWithColonsSurroundWithParenthesis);
            return escapedValues.join(', ');
        }
        else {
            if (escapedValues[0][0] === '(') {
                return escapedValues.join(', ');
            }
            return glueWithColonsSurroundWithParenthesis(escapedValues);
        }
    };
    QueryFormat.prototype.queryFormat = function (query, values) {
        if (!query)
            throw new Error('A query must be provided');
        if (!values)
            return query;
        this.values = values;
        if (this.values instanceof Array) {
            this.copyOfValuesWhenArray = Object.assign([], values);
        }
        var regex = /\:([A-Za-z0-9_?]+)/g;
        var matches = query.match(regex);
        if (matches === null) {
            throw new Error('Your query does not contain any placeholder');
        }
        this.matchesCount = matches.length;
        return query.replace(regex, this.replacer);
    };
    QueryFormat.prototype.replacer = function (ref, key) {
        var _this = this;
        if (this.values === null)
            throw new Error('Need to pass the values in first');
        var ret;
        // question mark
        if (key === '?') {
            // single :?
            // a) stringable array array
            // b) object stringable
            // many :?, :?
            // c) stringable array
            // d) stringable array array
            if (isStringableObj(this.values)) {
                // b) object stringable
                return Object.keys(this.values).map(function (k) {
                    var val = _this.values[k];
                    return val === null
                        ? "".concat(k, " IS NULL")
                        : "".concat(k, " = ").concat(_this.escape(val));
                    return;
                }).join(' AND ');
            }
            else if (!this.copyOfValuesWhenArray) {
                throw new Error('the :? placeholder requires values to be an array');
            }
            // is stringable array (why not put ourselves in else of isStringableObject above?)
            if (this.matchesCount === 1) {
                if (isStringableArrayArray(this.copyOfValuesWhenArray)) {
                    // a) stringable array array
                    ret = this.mapEscape(this.copyOfValuesWhenArray, 0, ref); // string[][]
                }
                else {
                    // -> unknown case)
                    ret = this.mapEscape(this.copyOfValuesWhenArray, 0, ref); // string[]
                }
            }
            else { // matchesCount =0 or >=2
                // c) stringable array
                // d) stringable array array
                if (this.copyOfValuesWhenArray === null)
                    throw new Error('This should have been set before');
                var replaceWithNext = this.copyOfValuesWhenArray.shift();
                if (replaceWithNext === undefined) {
                    throw new Error('More question marks than elements');
                }
                else if (isStringableArray(replaceWithNext)) {
                    ret = this.mapEscape(replaceWithNext, 0, ref); // stringable[]
                }
                else if (isStringable(replaceWithNext)) {
                    ret = this.mapEscape(replaceWithNext, 0, ref); // stringable
                }
            }
            // single :ref
            // e) object stringable array
            // f) object stringable array array
            // many :ref, :ref
            // g) object stringable
            // h) object stringable array
        }
        else if (this.values.hasOwnProperty(key)) { // Not question mark aka -> named palceholders
            if (isStringableObj(this.values)) {
                // g) object stringable
                ret = this.mapEscape(this.values[key], 0, ref); // stringable
            }
            else if (isStringableArrayObj(this.values) && this.values.hasOwnProperty(key)) {
                // e) object stringable array
                // h) object stringable array
                ret = this.mapEscape(this.values[key], 0, ref); // stringable[]
            }
            else if (isStringableArrayArrayObj(this.values) && this.values.hasOwnProperty(key)) {
                // f) object stringable array array
                ret = this.mapEscape(this.values[key], 0, ref); // stringable[]
            }
            else if (isStringableMixedObj(this.values)) {
                // i) values is a mix of different types
                ret = this.mapEscape(this.values[key], 0, ref); // stringable[]
            }
        }
        else { // named ref not present in values (dont replace anything)
            throw new Error("Provided named ref: '".concat(ref, "' without corresponding value, keys are: ").concat(Object.keys(this.values).join(', '), "\n        values: ").concat(Object.values(this.values).join(', '), "\n        hasOwnProperty : ").concat((this.values.hasOwnProperty(key) ? 'yes' : 'no'), "\n        Note: It may be a Promise, make sure all values are Stringable type and not some Promise lying around"));
        }
        // for ts overload recognition
        if (typeof ret === 'string') {
            return this.joinUseParenthesis(ret);
        }
        else if (isStringableArray(ret)) {
            return this.joinUseParenthesis(ret);
        }
        else if (isStringableArrayArray(ret)) {
            return this.joinUseParenthesis(ret);
        }
        else {
            console.log('========== ERRAH ============');
            console.log('An error is going to be raised, probably because you passed an object with more props than used');
            console.log('REF   : : : ', ref);
            console.log('KEY   : : : ', key);
            console.log('VALUES: : : ', this.values);
            console.log('RETRET: : : ', ret);
            throw new Error("Ret: ".concat(ret, " is somehow undefined, not all cases have been handled, you are trying an unsupported usecase\n        Provided named ref: '").concat(ref, "' without corresponding value, keys are: ").concat(Object.keys(this.values).join(', '), "\n        values: ").concat(Object.values(this.values).join(', '), "\n        hasOwnProperty : ").concat((this.values.hasOwnProperty(key) ? 'yes' : 'no'), "\n        Note: It may be a Promise, make sure all values are Stringable type and not some Promise lying around"));
        }
    };
    return QueryFormat;
}());
exports.default = QueryFormat;
